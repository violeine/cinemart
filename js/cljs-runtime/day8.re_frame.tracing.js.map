{"version":3,"sources":["day8/re_frame/tracing.cljc"],"mappings":";AAaS,AAACA;AAED;;;AAAA,AAAAC,AAAA,AAAA,AAAaC;AAGtB;;;AAAA,AAAeC;AAAf,AAOED;;AAEF,AAAKE,AAAoBC;AACzB,AAAKC,AAAsBC;AAgB3B,AAAA,AAAMC,AAAcC;AAApB,AAAA;AAEE,AAAOC,AAAI,AAACC,AAAkBF;AAA9B,AACOG;;AADP,AAEE,AAAMC,AAAK,AAACC,AAAOJ;AAAnB,AACE,AACE,AAACK,AAAOL;AAAKE;;AADf,AAEE,AAAAI,AAASH;AAAM,AAAO,AAACI,AAAOP;AAAK,AAACQ,AAAKN,AAAKC;;;;;AAFhD,AAGQ,AAAO,AAACI,AAAOP;AAAKE;;;;;;;;;;AAGlC,AAAA,AAAA,AAAAO,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAASM,AAAYC;AAA3B,AACE,AAAMvB,AAAgB,AAAAwB,AAAI,AAAA,AAAA,AAAA,AAAIF;AAAR,AAAA,AAAAE;AAAAA;;AAAA;;;AAChBC,AAAoBH,AAAgB,AAAA,AAAA,AAAA,AAACI;AACrCC,AAAgB,AAAA,AAACD,AAAI,AAAA,AAAOJ;AAC5BM,AAAgB,AAAC7B,AAAaC;AAHpC,AAIE,AAAI,AAAA,AAACiC,AAAQR;AAAb,AAAAI,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACKhC,AAEiB2B,AAAMJ,AAAWK;;AAHvC,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAKKhC,AACA,AAAA,AAAU2B,AACO,AAAA,AAAOA,AAAOJ,AAAWK;;;;AAZnD,AAAA,AAAA,AAAMZ;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA,AAAAC,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAA,AAAA,AAAAI,AAAA;AAAA,AAAA,AAAAA,AAAAH,AAAAD;;;AAAA","names":["cljs.core/enable-console-print!","js/goog.define","day8.re-frame.tracing/trace-enabled?","day8.re-frame.tracing/is-trace-enabled?","day8.re-frame.tracing/reset-indent-level!","day8.re-frame.debux.common.util/reset-indent-level!","day8.re-frame.tracing/set-print-seq-length!","day8.re-frame.debux.common.util/set-print-seq-length!","day8.re-frame.tracing/find-symbols","args","loc","day8.re-frame.debux.common.util/sequential-zip","seen","node","clojure.zip/node","clojure.zip/end?","cljs.core/Symbol","clojure.zip/next","cljs.core.conj","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","day8.re-frame.tracing/fn-body","seq25104","G__25105","cljs.core/first","cljs.core/next","self__4723__auto__","args+body","send-form","or__4126__auto__","body-or-prepost","cljs.core.nth","body","args-symbols","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core._EQ_"],"sourcesContent":["(ns day8.re-frame.tracing\n  #?(:cljs (:require-macros\n             [day8.re-frame.debux.dbgn :as dbgn]\n             [day8.re-frame.debux.cs.macro-types :as mt]\n             [day8.re-frame.tracing])\n     :clj (:require\n            [day8.re-frame.debux.dbgn :as dbgn]\n            [day8.re-frame.debux.cs.macro-types :as mt]))\n  (:require [day8.re-frame.debux.common.util :as ut]\n            [day8.re-frame.debux.common.macro-specs :as ms]\n            [clojure.spec.alpha :as s]\n            [clojure.zip :as z]))\n\n#?(:cljs (enable-console-print!))\n\n#?(:cljs (goog-define trace-enabled? false)\n   :clj  (def ^boolean trace-enabled? false))\n\n(defn ^boolean is-trace-enabled?\n  \"See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\"\n  ;; We can remove this extra step of type hinting indirection once our minimum CLJS version includes\n  ;; https://dev.clojure.org/jira/browse/CLJS-1439\n  ;; r1.10.63 is the first version with this:\n  ;; https://github.com/clojure/clojurescript/commit/9ec796d791b1b2bd613af2f62cdecfd25caa6482\n  []\n  trace-enabled?)\n\n(def reset-indent-level! ut/reset-indent-level!)\n(def set-print-seq-length! ut/set-print-seq-length!)\n\n\n;;; debugging APIs\n(defmacro dbgn [form & opts]\n  (let [opts' (ut/parse-opts opts)]\n    `(day8.re-frame.debux.dbgn/dbgn ~form ~opts')))\n\n;;; macro registering APIs\n(defmacro register-macros! [macro-type symbols]\n  `(day8.re-frame.debux.cs.macro-types/register-macros! ~macro-type ~symbols))\n\n(defmacro show-macros\n  ([] `(day8.re-frame.debux.cs.macro-types/show-macros))\n  ([macro-type] `(day8.re-frame.debux.cs.macro-types/show-macros ~macro-type)))\n\n(defn find-symbols [args]\n  \"iterate through the function args and get a list of the symbols\"\n  (loop [loc (ut/sequential-zip args)\n         seen []]\n    (let [node (z/node loc)]\n      (cond\n        (z/end? loc) seen\n        (symbol? node) (recur (z/next loc) (conj seen node))\n        :else (recur (z/next loc) seen)\n        ))))\n\n(defn fn-body [args+body & send-form]\n  (let [args            (or (-> args+body :args :args) [])\n        body-or-prepost (-> args+body :body (nth 0))\n        body            (nth (:body args+body) 1)\n        args-symbols    (find-symbols args)]\n    (if (= :body body-or-prepost)   ;; no pre and post conditions\n      `(~args\n      ;;  ~@(map (fn [body] `(dbgn ~body)) (nth (:body args+body) 1)))\n        (dbgn/dbgn-forms ~body ~send-form ~args-symbols))\n    ;; prepost+body\n      `(~args\n        ~(:prepost body)\n        (dbgn/dbgn-forms ~(:body body) ~send-form ~args-symbols)))))\n\n;; Components of a defn\n;; name\n;; docstring?\n;; meta?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro defn-traced*\n  [& definition]\n  (let [conformed (s/conform ::ms/defn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      `(defn ~name ~@(fn-body args+body &form))\n      `(defn ~name ~@(map #(fn-body % &form) (:bodies args+body))))))\n\n(defmacro defn-traced\n  \"Traced defn\"\n  {:arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (defn-traced* ~@definition)\n     (defn ~@definition)))\n\n\n\n;; Components of a fn\n;; name?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro fn-traced*\n  \"Traced form of fn. Prefer fn-traced to compile out under advanced optimizations.\"\n  [& definition]\n  (let [conformed (s/conform ::ms/fn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      ;; If name is nil, then the empty vector is removed by the unquote\n      `(fn ~@(when name [name])\n         ~@(fn-body args+body &form))\n      ;; arity-n\n      (let [bodies (:bodies args+body)]\n        `(fn ~@(when name [name])\n           ~@(map #(fn-body % &form) bodies))))))\n\n(defmacro fn-traced\n  \"Defines a traced fn\"\n  {:arglists '[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (fn-traced* ~@definition)\n     (fn ~@definition)))\n\n"]}